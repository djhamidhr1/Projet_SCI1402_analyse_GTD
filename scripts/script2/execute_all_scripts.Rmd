---
title: "Exécution complète des scripts GTD"
author: "HAMID DIGORGORD"
date: "`r Sys.Date()`"
output: html_document
---

# Exécution complète des scripts R

Ce document permet d'exécuter **tous les scripts** R dans l'ordre, de l'installation des packages jusqu'à la prédiction des attaques.

```{r setup, include=FALSE}
# Charger les bibliothèques nécessaires
library(here)

# Définir le répertoire de travail à la racine du projet
setwd(here())  # Utilise here() pour pointer automatiquement vers la racine
print(getwd())  # Vérification du répertoire

# Liste des scripts à exécuter
scripts <- c(
  "scripts/001_installation_packages.R",
  "scripts/002_configuration_environnement.R",
  "scripts/003_data_import_spark_r.R",
  "scripts/004_nettoyage-data.R",
  "scripts/005_analyse_exploratoire.R",
  "scripts/006_analyse_statistique.R",
  "scripts/007_visualisation_details.R",
  "scripts/009_cartes_regionales.R",
  "scripts/010_models_prédictifs.R",
  "scripts/011_prédiction_atack.R"
)

# Fonction pour exécuter les scripts avec vérification
execute_scripts <- function(script_list) {
  for (script in script_list) {
    cat(paste0("\n--- Exécution de : ", script, " ---\n"))
    if (file.exists(script)) {
      source(script)
      cat(paste0("Le script ", script, " a été exécuté avec succès.\n"))
    } else {
      warning(paste0("ATTENTION : Le fichier ", script, " est introuvable.\n"))
    }
  }
}

# Exécution des scripts
execute_scripts(scripts)
```



```{r setup, include=FALSE}
# ==============================================================================
#                    CONFIGURATION DE L'ENVIRONNEMENT R
# ==============================================================================

# -----------------------------------------------------------------------------
#                    1. CHARGEMENT DES PACKAGES
# -----------------------------------------------------------------------------

cat("=== CHARGEMENT DES PACKAGES ===\n")

# 1.1 Data manipulation et visualisation
library(tidyverse)  # Inclut ggplot2, dplyr, tidyr, readr, etc.
library(scales)     # Formatage des échelles
library(gridExtra)  # Organisation des graphiques

# 1.2 Visualisation géographique
library(leaflet)    # Cartes interactives
library(sf)         # Données géographiques
library(maps)       # Données cartographiques
library(mapdata)    # Données supplémentaires

# 1.3 Palettes et couleurs
library(RColorBrewer)  # Palettes de couleurs
library(viridis)       # Palettes accessibles

# 1.4 Visualisation avancée
library(plotly)      # Graphiques interactifs
library(treemapify)  # Création de treemaps
library(corrplot)    # Matrices de corrélation
library(gganimate)   # Animations
library(animation)   # Support d'animation

# 1.5 Analyse statistique
library(cluster)     # Analyse de clustering
library(factoextra)  # Visualisation clusters

# 1.6 Manipulation temporelle
library(lubridate)   # Gestion des dates

# -----------------------------------------------------------------------------
#                    2. VÉRIFICATION DE L'ENVIRONNEMENT
# -----------------------------------------------------------------------------

cat("\n=== VÉRIFICATION DE L'ENVIRONNEMENT ===\n")

# 2.1 Affichage des packages chargés
cat("\nPackages actuellement chargés:\n")
print(.packages())

# 2.2 Vérification de la version de R
cat("\nVersion de R:", R.version.string, "\n")

# 2.3 Vérification du répertoire de travail
cat("\nRépertoire de travail:", getwd(), "\n")

# -----------------------------------------------------------------------------
#                    3. PARAMÈTRES GÉNÉRAUX
# -----------------------------------------------------------------------------

# 3.1 Configuration des options de base
options(
  digits = 4,              # Nombre de décimales
  stringsAsFactors = FALSE,# Ne pas convertir les chaînes en facteurs
  timeout = 120,           # Timeout pour les téléchargements
  encoding = "UTF-8"       # Encodage par défaut
)

# 3.2 Configuration de ggplot2 pour une meilleure visualisation
theme_set(theme_minimal())  # Thème par défaut pour ggplot2

cat("\n=== CONFIGURATION TERMINÉE ===\n")

# ==============================================================================
#                    CONFIGURATION DE SPARK
# ==============================================================================

# -----------------------------------------------------------------------------
#                    1. CHARGEMENT DE SPARKLYR
# -----------------------------------------------------------------------------

cat("=== CONFIGURATION DE SPARK ===\n")

# Chargement du package sparklyr
library(sparklyr)

# -----------------------------------------------------------------------------
#                    2. INSTALLATION DE SPARK
# -----------------------------------------------------------------------------

# 2.1 Installation de la version spécifiée de Spark
cat("\nInstallation de Spark...\n")
spark_install(version = "3.5.1")

# -----------------------------------------------------------------------------
#                    3. CONFIGURATION DE SPARK
# -----------------------------------------------------------------------------

# 3.1 Fonction de configuration
configure_spark <- function() {
  config <- spark_config()
  
  # Configuration de la mémoire
  config$`sparklyr.shell.driver-memory` <- "2G"
  config$`sparklyr.shell.executor-memory` <- "2G"
  
  # Configuration additionnelle (à décommenter si nécessaire)
  # config$spark.executor.cores <- 2
  # config$spark.executor.instances <- 1
  # config$spark.dynamicAllocation.enabled <- "true"
  
  return(config)
}

# -----------------------------------------------------------------------------
#                    4. CONNEXION À SPARK
# -----------------------------------------------------------------------------

# 4.1 Fonction de connexion
connect_to_spark <- function() {
  tryCatch({
    config <- configure_spark()
    sc <- spark_connect(
      master = "local",
      version = "3.5.1",
      config = config
    )
    cat("Connexion à Spark établie avec succès!\n")
    return(sc)
  }, error = function(e) {
    cat("Erreur lors de la connexion à Spark:", conditionMessage(e), "\n")
    return(NULL)
  })
}

# -----------------------------------------------------------------------------
#                    5. FONCTIONS UTILITAIRES
# -----------------------------------------------------------------------------

# 5.1 Fonction pour arrêter Spark
stop_spark <- function(sc) {
  if (!is.null(sc)) {
    spark_disconnect(sc)
    cat("Déconnexion de Spark effectuée.\n")
  }
}

# 5.2 Fonction pour vérifier l'état de Spark
check_spark_status <- function(sc) {
  if (!is.null(sc) && spark_connection_is_open(sc)) {
    cat("Spark est connecté et fonctionnel.\n")
    cat("Version de Spark:", spark_version(sc), "\n")
  } else {
    cat("Spark n'est pas connecté.\n")
  }
}

cat("\n=== CONFIGURATION SPARK TERMINÉE ===\n")
cat("\nPour utiliser Spark:\n")
cat("1. sc <- connect_to_spark()\n")
cat("2. check_spark_status(sc)\n")
cat("3. Pour arrêter: stop_spark(sc)\n")
```




```{r setup, include=FALSE}

# ==============================================================================
#                 IMPORTATION ET TRAITEMENT DES DONNÉES
# ==============================================================================

# -----------------------------------------------------------------------------
#                1. CONFIGURATION INITIALE
# -----------------------------------------------------------------------------

# 1.1 Chargement des packages nécessaires
library(tidyverse)  # Manipulation des données
library(sparklyr)   # Interface avec Apache Spark
library(arrow)      # Manipulation des fichiers Parquet
library(readr)      # Lecture rapide des fichiers CSV

# 1.2 Configuration des chemins d'accès
PATHS <- list(
  RAW_DATA = "../data/raw/globalterrorismdb_0718dist.csv",  # Chemin vers le fichier brut
  PROCESSED_CSV = "../data/processed/gtd_clean.csv",       # Chemin pour sauvegarde CSV
  PROCESSED_PARQUET = "../data/processed/gtd_clean.parquet" # Chemin pour sauvegarde Parquet
)

# 1.3 Création des répertoires nécessaires
for (path in PATHS) {
  dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
}

# -----------------------------------------------------------------------------
#                2. FONCTIONS D'IMPORTATION
# -----------------------------------------------------------------------------

# 2.1 Importation avec R
import_with_r <- function(file_path) {
  message("\n--- Importation des données avec R ---")
  tryCatch({
    data <- read_csv(file_path) %>%
      select(
        year = iyear, month = imonth, day = iday,
        country = country_txt, region = region_txt, city,
        latitude, longitude, attack_type = attacktype1_txt,
        target_type = targtype1_txt, weapon_type = weaptype1_txt,
        killed = nkill, wounded = nwound, property, success
      )
    message("Importation réussie avec R!")
    return(data)
  }, error = function(e) {
    message("Erreur lors de l'importation R: ", e$message)
    return(NULL)
  })
}

# -----------------------------------------------------------------------------
#                3. AFFICHAGE DES DONNÉES
# -----------------------------------------------------------------------------

afficher_donnees <- function(data) {
  message("\n--- Aperçu des données ---")
  print(head(data, 10))  # Afficher les 10 premières lignes
  print(str(data))       # Structure des données
  print(summary(data))   # Résumé statistique
}

# -----------------------------------------------------------------------------
#                4. FONCTIONS D'ANALYSE ET STOCKAGE
# -----------------------------------------------------------------------------

# 4.1 Sauvegarde des données en CSV ou Parquet
store_data <- function(data, output_path, format = "csv") {
  message(sprintf("\n--- Sauvegarde des données en format %s ---", format))
  tryCatch({
    if (format == "parquet") {
      write_parquet(data, output_path)
    } else if (format == "csv") {
      write_csv(data, output_path)
    }
    message("Données sauvegardées avec succès dans : ", output_path)
  }, error = function(e) {
    message("Erreur lors de la sauvegarde: ", e$message)
  })
}

# -----------------------------------------------------------------------------
#                5. EXÉCUTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
  message("\n=== Début du traitement des données ===")
  
  # 5.1 Importation des données
  data <- import_with_r(PATHS$RAW_DATA)
  
  # 5.2 Affichage des données avant nettoyage
  if (!is.null(data)) {
    afficher_donnees(data)
    
    # 5.3 Sauvegarde des données brutes
    store_data(data, PATHS$PROCESSED_CSV, "csv")
    store_data(data, PATHS$PROCESSED_PARQUET, "parquet")
  } else {
    message("Aucune donnée importée. Vérifiez le chemin d'accès.")
  }
  
  message("\n=== Fin du traitement des données ===")
}

# -----------------------------------------------------------------------------
#                6. LANCEMENT DU SCRIPT
# -----------------------------------------------------------------------------

if (!interactive()) {
  main()
} else {
  message("\nExécution en mode interactif...")
  data_test <- import_with_r(PATHS$RAW_DATA)
  afficher_donnees(data_test)
}
```




```{r setup, include=FALSE}
# ==============================================================================
#                    NETTOYAGE DES DONNÉES GTD 
# ==============================================================================

# Configuration de l'encodage et de l'environnement
Sys.setlocale("LC_ALL", "UTF-8")
options(encoding = "UTF-8")

# -----------------------------------------------------------------------------
#                    1. CHARGEMENT DES PACKAGES
# -----------------------------------------------------------------------------
library(tidyverse)  # Manipulation de données
library(stringi)    # Nettoyage de texte
library(lubridate)  # Manipulation de dates

# -----------------------------------------------------------------------------
#                    2. DÉFINITION DES CHEMINS
# -----------------------------------------------------------------------------
PATHS <- list(
  INPUT = "C:/Users/digor/OneDrive/Documents/Projet_SCI1402_analyse_GTD/data/raw/globalterrorismdb_0718dist.csv", # Chemin absolu
  OUTPUT = "C:/Users/digor/OneDrive/Documents/Projet_SCI1402_analyse_GTD/data/processed/gtd_clean.csv",
  TEMP = "C:/Users/digor/OneDrive/Documents/Projet_SCI1402_analyse_GTD/data/temp"
)

# Création des répertoires nécessaires
for (path in PATHS) {
  dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
}

# -----------------------------------------------------------------------------
#                    3. FONCTIONS DE NETTOYAGE
# -----------------------------------------------------------------------------

# 3.1 Nettoyage de texte sécurisé
safe_clean_text <- function(text) {
  if (is.na(text)) return(NA_character_)
  if (text == "") return(NA_character_)
  
  cleaned <- text %>%
    stri_encode("UTF-8", "UTF-8") %>%
    stri_trim_both() %>%
    str_squish()
  
  if (cleaned == "") return(NA_character_)
  return(cleaned)
}

# 3.2 Nettoyage des dates
clean_dates <- function(data) {
  message("Nettoyage des dates...")
  
  data %>%
    mutate(
      year = iyear,
      month = if_else(between(imonth, 1, 12), imonth, NA_integer_),
      day = if_else(between(iday, 1, 31), iday, NA_integer_),
      date = make_date(year, month, day)
    )
}

# 3.3 Nettoyage des localisations
clean_locations <- function(data) {
  message("Nettoyage des localisations...")
  
  data %>%
    mutate(
      country = safe_clean_text(country_txt),
      region = safe_clean_text(region_txt),
      city = case_when(
        city == "Unknown" ~ "Unknown",
        TRUE ~ safe_clean_text(city)
      ),
      latitude = if_else(between(latitude, -90, 90), latitude, NA_real_),
      longitude = if_else(between(longitude, -180, 180), longitude, NA_real_)
    )
}

# 3.4 Nettoyage des informations d'attaque
clean_attack_info <- function(data) {
  message("Nettoyage des informations d'attaque...")
  
  data %>%
    mutate(
      attack_type = safe_clean_text(attacktype1_txt),
      target_type = safe_clean_text(targtype1_txt),
      weapon_type = safe_clean_text(weaptype1_txt),
      killed = if_else(nkill < 0 | is.na(nkill), 0, nkill),
      wounded = if_else(nwound < 0 | is.na(nwound), 0, nwound),
      total_casualties = killed + wounded,
      success = as.logical(success)
    )
}

# 3.5 Gestion des valeurs manquantes
handle_missing_values <- function(data) {
  message("Gestion des valeurs manquantes...")
  
  data %>%
    mutate(across(where(is.character), ~replace_na(., "Unknown"))) %>%
    mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
    mutate(across(where(is.logical), ~replace_na(., FALSE)))
}

# -----------------------------------------------------------------------------
#                    4. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
  message("\n=== DÉBUT DU NETTOYAGE DES DONNÉES ===\n")
  
  tryCatch({
    # 4.1 Lecture des données brutes
    message("Lecture du fichier source...")
    gtd_data <- read_csv(
      PATHS$INPUT,
      locale = locale(encoding = "UTF-8"),
      show_col_types = FALSE
    )
    
    # 4.2 Application des étapes de nettoyage
    gtd_clean <- gtd_data %>%
      clean_dates() %>%
      clean_locations() %>%
      clean_attack_info() %>%
      handle_missing_values()
    
    # 4.3 Sauvegarde des données nettoyées
    message("Sauvegarde des données nettoyées...")
    write_csv(gtd_clean, PATHS$OUTPUT)
    
    # 4.4 Affichage des statistiques finales
    message("\nStatistiques finales :")
    summary_stats <- gtd_clean %>%
      summarise(
        total_incidents = n(),
        total_countries = n_distinct(country),
        period = paste(min(year, na.rm = TRUE), "-", max(year, na.rm = TRUE)),
        total_killed = sum(killed, na.rm = TRUE),
        total_wounded = sum(wounded, na.rm = TRUE)
      )
    print(summary_stats)
    
    message("\n=== NETTOYAGE TERMINÉ AVEC SUCCÈS ===")
    
  }, error = function(e) {
    message("\nERREUR : ", e$message)
  })
}

# -----------------------------------------------------------------------------
#                    5. EXÉCUTION DU SCRIPT
# -----------------------------------------------------------------------------

if (!interactive()) {
  main()
} else {
  message("Exécution interactive...")
  main()
}
```


```{r setup, include=FALSE}
# ==============================================================================
#                    ANALYSE EXPLORATOIRE DES DONNÉES GTD
# ==============================================================================

# Configuration de l'encodage et de l'environnement
Sys.setlocale("LC_ALL", "UTF-8")
options(encoding = "UTF-8")

# Chargement des packages nécessaires
library(tidyverse)
library(lubridate)
library(ggplot2)
library(scales)
library(here)

# -----------------------------------------------------------------------------
#                    1. DÉFINITION DES CHEMINS
# -----------------------------------------------------------------------------

PATHS <- list(
  INPUT = here("data", "processed", "gtd_clean.csv"),
  OUTPUT = here("outputs", "figures")
)

# Vérification de l'existence du fichier d'entrée
if (!file.exists(PATHS$INPUT)) {
  stop("Erreur : Le fichier gtd_clean.csv est introuvable. Vérifiez le chemin d'accès.")
}

# Création des dossiers nécessaires
dir.create(PATHS$OUTPUT, recursive = TRUE, showWarnings = FALSE)

# -----------------------------------------------------------------------------
#                    2. CHARGEMENT DES DONNÉES
# -----------------------------------------------------------------------------

gtd_data <- read_csv(PATHS$INPUT, show_col_types = FALSE)

# Validation des données
cat("\nStructure des données :\n")
print(glimpse(gtd_data))

cat("\nStatistiques descriptives :\n")
print(summary(gtd_data))

# -----------------------------------------------------------------------------
#                    3. PRÉPARATION DES DONNÉES
# -----------------------------------------------------------------------------

# Création de la colonne total_casualties (somme des tués et blessés)
if (!"total_casualties" %in% colnames(gtd_data)) {
  cat("\nCréation de la colonne 'total_casualties'...\n")
  gtd_data <- gtd_data %>%
    mutate(total_casualties = killed + wounded)
}

# Vérification des colonnes disponibles
cat("\nColonnes disponibles dans gtd_data :\n")
print(colnames(gtd_data))

# Aperçu des premières lignes des données
cat("\nAperçu des données :\n")
print(head(gtd_data))

# -----------------------------------------------------------------------------
#                    4. VISUALISATIONS EXPLORATOIRES
# -----------------------------------------------------------------------------

# 4.1 Distribution des types d'attaque
distribution_attacks <- ggplot(gtd_data, aes(x = fct_infreq(attack_type))) +
  geom_bar(fill = "skyblue") +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Distribution des types d'attaques",
    x = "Type d'attaque",
    y = "Nombre d'incidents"
  )

ggsave(file.path(PATHS$OUTPUT, "distribution_attacks.png"), distribution_attacks)
cat("\nGraphique 'distribution_attacks.png' sauvegardé.\n")

# 4.2 Évolution annuelle des incidents
evolution_annual <- gtd_data %>%
  group_by(year) %>%
  summarise(total_incidents = n()) %>%
  ggplot(aes(x = year, y = total_incidents)) +
  geom_line(color = "red") +
  theme_minimal() +
  labs(
    title = "Évolution annuelle des incidents",
    x = "Année",
    y = "Nombre total d'incidents"
  )

ggsave(file.path(PATHS$OUTPUT, "evolution_annual.png"), evolution_annual)
cat("\nGraphique 'evolution_annual.png' sauvegardé.\n")

# 4.3 Distribution géographique des incidents
distribution_regions <- gtd_data %>%
  count(region) %>%
  ggplot(aes(x = fct_reorder(region, n), y = n)) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Distribution géographique des incidents",
    x = "Région",
    y = "Nombre d'incidents"
  )

ggsave(file.path(PATHS$OUTPUT, "distribution_regions.png"), distribution_regions)
cat("\nGraphique 'distribution_regions.png' sauvegardé.\n")

# -----------------------------------------------------------------------------
#                    5. ANALYSES STATISTIQUES DE BASE
# -----------------------------------------------------------------------------

# Statistiques de base sur les victimes
victim_stats <- gtd_data %>%
  summarise(
    mean_killed = mean(killed, na.rm = TRUE),
    mean_wounded = mean(wounded, na.rm = TRUE),
    mean_casualties = mean(total_casualties, na.rm = TRUE)
  )

cat("\nStatistiques sur les victimes :\n")
print(victim_stats)

# -----------------------------------------------------------------------------
#                    6. CONCLUSION
# -----------------------------------------------------------------------------

cat("\n=== ANALYSE EXPLORATOIRE TERMINÉE ===\n")

```


```{r setup, include=FALSE}
# ==============================================================================
#                    ANALYSE STATISTIQUE DES DONNÉES GTD
# ==============================================================================

# Chargement des packages nécessaires
library(tidyverse)
library(corrplot)
library(tsibble)
library(feasts)
library(lubridate)
library(broom)
library(scales)
library(fable)
library(gridExtra)
library(here)

# -----------------------------------------------------------------------------
#                    1. CHARGEMENT ET PRÉPARATION
# -----------------------------------------------------------------------------

load_gtd_data <- function() {
  input_path <- here("data", "processed", "gtd_clean.csv")
  
  # Vérification de l'existence du fichier
  if (!file.exists(input_path)) {
    stop("Erreur : Le fichier 'gtd_clean.csv' est introuvable dans 'data/processed/'.")
  }
  
  message("\nChargement des données...")
  data <- read_csv(input_path, show_col_types = FALSE)
  return(data)
}

# -----------------------------------------------------------------------------
#                    2. ANALYSE EXPLORATOIRE (EDA)
# -----------------------------------------------------------------------------

analyze_distributions <- function(data) {
  message("\n=== ANALYSE DES DISTRIBUTIONS ===")
  
  # Distribution des attaques par type
  p1 <- ggplot(data, aes(x = attack_type)) +
    geom_bar(fill = "skyblue") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Distribution des types d'attaques",
         x = "Type d'attaque", y = "Nombre d'incidents")
  
  # Distribution géographique
  p2 <- ggplot(data, aes(x = region)) +
    geom_bar(fill = "orange") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = "Distribution par région",
         x = "Région", y = "Nombre d'incidents")
  
  # Distribution des victimes
  p3 <- ggplot(data, aes(x = killed)) +
    geom_histogram(binwidth = 1, fill = "red") +
    scale_x_log10(breaks = 10^(0:4)) +
    theme_minimal() +
    labs(title = "Distribution du nombre de victimes (\u00e9chelle log)",
         x = "Nombre de victimes", y = "Fréquence")
  
  grid.arrange(p1, p2, p3, ncol = 2)
  
  return(list(p1 = p1, p2 = p2, p3 = p3))
}

analyze_correlations <- function(data) {
  message("\n=== ANALYSE DES CORRÉLATIONS ===")
  
  # Sélection des variables numériques
  numeric_data <- data %>%
    select(killed, wounded, latitude, longitude) %>%
    drop_na()
  
  corr_matrix <- cor(numeric_data)
  
  # Création de la matrice de corrélation
  corrplot(corr_matrix, 
           method = "color",
           type = "upper",
           addCoef.col = "black",
           tl.col = "black",
           tl.srt = 45)
}

# -----------------------------------------------------------------------------
#                    3. STATISTIQUES DESCRIPTIVES
# -----------------------------------------------------------------------------

calculate_descriptive_stats <- function(data) {
  message("\n=== STATISTIQUES DESCRIPTIVES ===")
  
  stats_general <- data %>%
    summarise(
      total_incidents = n(),
      total_killed = sum(killed, na.rm = TRUE),
      total_wounded = sum(wounded, na.rm = TRUE),
      mean_killed = mean(killed, na.rm = TRUE),
      sd_killed = sd(killed, na.rm = TRUE)
    )
  
  print(stats_general)
  return(stats_general)
}

# -----------------------------------------------------------------------------
#                    4. TESTS STATISTIQUES ET RÉGRESSION
# -----------------------------------------------------------------------------

perform_chi_square_tests <- function(data) {
  message("\n=== TEST DE CHI-CARRÉ ===")
  
  # Table de contingence entre région et type d'attaque
  contingency_table <- table(data$region, data$attack_type)
  chi_test <- chisq.test(contingency_table)
  
  print(chi_test)
  return(chi_test)
}

perform_regression_analysis <- function(data) {
  message("\n=== ANALYSE DE RÉGRESSION ===")
  
  # Modèle de régression
  model <- lm(killed ~ wounded + region + attack_type, data = data)
  print(summary(model))
  
  return(model)
}

# -----------------------------------------------------------------------------
#                    5. ANALYSE TEMPORELLE
# -----------------------------------------------------------------------------

analyze_time_series <- function(data) {
  message("\n=== ANALYSE DES SÉRIES TEMPORELLES ===")
  
  # Série temporelle agrégée par mois
  monthly_data <- data %>%
    mutate(date = as.Date(date)) %>%
    group_by(month = floor_date(date, "month")) %>%
    summarise(total_incidents = n(), .groups = "drop")
  
  p <- ggplot(monthly_data, aes(x = month, y = total_incidents)) +
    geom_line(color = "blue") +
    theme_minimal() +
    labs(title = "Nombre d'incidents par mois",
         x = "Mois", y = "Nombre total d'incidents")
  
  print(p)
}

# -----------------------------------------------------------------------------
#                    6. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
  # Chargement des données
  data <- load_gtd_data()
  
  # Analyse exploratoire
  analyze_distributions(data)
  analyze_correlations(data)
  
  # Statistiques descriptives
  stats <- calculate_descriptive_stats(data)
  
  # Tests statistiques
  perform_chi_square_tests(data)
  perform_regression_analysis(data)
  
  # Analyse temporelle
  analyze_time_series(data)
  
  message("\n=== ANALYSE STATISTIQUE TERMINÉE ===")
}

# Exécution de la fonction principale
if (!interactive()) {
  main()
}
```


```{r setup, include=FALSE}
# ==============================================================================
#                    VISUALISATIONS DÉTAILLÉES DES DONNÉES GTD
# ==============================================================================

library(tidyverse)
library(corrplot)
library(gridExtra)
library(scales)
library(viridis)
library(maps)

# -----------------------------------------------------------------------------
#                    1. DISTRIBUTIONS ET TENDANCES GÉNÉRALES
# -----------------------------------------------------------------------------

plot_attack_distributions <- function(data) {
  # Distribution par type d'attaque
  p1 <- ggplot(data, aes(x = reorder(attack_type, attack_type, function(x) length(x)))) +
    geom_bar(aes(fill = ..count..)) +
    scale_fill_viridis() +
    coord_flip() +
    theme_minimal() +
    labs(title = "Distribution des Types d'Attaques",
         x = "Type d'attaque",
         y = "Nombre d'incidents")
  
  # Évolution temporelle par type d'attaque
  p2 <- data %>%
    count(year, attack_type) %>%
    ggplot(aes(x = year, y = n, color = attack_type)) +
    geom_line() +
    theme_minimal() +
    labs(title = "Évolution des Types d'Attaques dans le Temps",
         x = "Année",
         y = "Nombre d'incidents",
         color = "Type d'attaque")
  
  print(p1)
  print(p2)
}

# -----------------------------------------------------------------------------
#                    2. ANALYSE GÉOGRAPHIQUE
# -----------------------------------------------------------------------------

plot_geographical_analysis <- function(data) {
  # Distribution par région
  p1 <- ggplot(data, aes(x = reorder(region, region, function(x) length(x)))) +
    geom_bar(aes(fill = ..count..)) +
    scale_fill_viridis() +
    coord_flip() +
    theme_minimal() +
    labs(title = "Nombre d'Incidents par Région",
         x = "Région",
         y = "Nombre d'incidents")
  
  # Carte des incidents
  world <- map_data("world")
  p2 <- ggplot() +
    geom_map(data = world, map = world,
             aes(long, lat, map_id = region),
             color = "white", fill = "lightgray") +
    geom_point(data = data,
               aes(x = longitude, y = latitude, color = killed),
               alpha = 0.5) +
    scale_color_viridis() +
    theme_minimal() +
    labs(title = "Distribution Géographique des Incidents",
         color = "Nombre de victimes")
  
  print(p1)
  print(p2)
}

# -----------------------------------------------------------------------------
#                    3. ANALYSE DES VICTIMES
# -----------------------------------------------------------------------------

plot_casualty_analysis <- function(data) {
  # Distribution des victimes
  p1 <- ggplot(data, aes(x = killed)) +
    geom_histogram(bins = 50, fill = "darkred", alpha = 0.7) +
    scale_x_log10() +
    theme_minimal() +
    labs(title = "Distribution du Nombre de Victimes (échelle log)",
         x = "Nombre de victimes",
         y = "Fréquence")
  
  # Victimes par région
  p2 <- data %>%
    group_by(region) %>%
    summarize(total_killed = sum(killed, na.rm = TRUE)) %>%
    ggplot(aes(x = reorder(region, total_killed), y = total_killed)) +
    geom_col(fill = "darkred", alpha = 0.7) +
    coord_flip() +
    theme_minimal() +
    labs(title = "Nombre Total de Victimes par Région",
         x = "Région",
         y = "Nombre total de victimes")
  
  print(p1)
  print(p2)
}

# -----------------------------------------------------------------------------
#                    4. ANALYSE DE CORRÉLATION
# -----------------------------------------------------------------------------

plot_correlation_analysis <- function(data) {
  # Matrice de corrélation
  numeric_data <- data %>%
    select(killed, wounded, year) %>%
    cor(use = "complete.obs")
  
  corrplot(numeric_data,
           method = "color",
           type = "upper",
           addCoef.col = "black",
           tl.col = "black",
           tl.srt = 45,
           title = "Matrice de Corrélation")
  
  # Relation entre tués et blessés
  p <- ggplot(data, aes(x = killed, y = wounded)) +
    geom_point(alpha = 0.5, color = "darkred") +
    geom_smooth(method = "lm", color = "blue") +
    scale_x_log10() +
    scale_y_log10() +
    theme_minimal() +
    labs(title = "Relation entre Nombre de Tués et de Blessés",
         x = "Nombre de tués (log)",
         y = "Nombre de blessés (log)")
  
  print(p)
}

# -----------------------------------------------------------------------------
#                    5. ANALYSE TEMPORELLE
# -----------------------------------------------------------------------------

plot_temporal_analysis <- function(data) {
  # Tendance annuelle
  p1 <- data %>%
    count(year) %>%
    ggplot(aes(x = year, y = n)) +
    geom_line(color = "darkred") +
    geom_smooth(method = "loess", color = "blue") +
    theme_minimal() +
    labs(title = "Évolution du Nombre d'Incidents par Année",
         x = "Année",
         y = "Nombre d'incidents")
  
  # Tendance mensuelle
  p2 <- data %>%
    group_by(year, month) %>%
    summarise(n = n(), .groups = "drop") %>%
    ggplot(aes(x = month, y = n, group = year, color = factor(year))) +
    geom_line(alpha = 0.5) +
    theme_minimal() +
    labs(title = "Tendance Mensuelle par Année",
         x = "Mois",
         y = "Nombre d'incidents",
         color = "Année")
  
  print(p1)
  print(p2)
}

# -----------------------------------------------------------------------------
#                    6. ANALYSE PAR TYPE D'ATTAQUE
# -----------------------------------------------------------------------------

plot_attack_type_analysis <- function(data) {
  # Succès par type d'attaque
  p1 <- data %>%
    group_by(attack_type) %>%
    summarise(success_rate = mean(success, na.rm = TRUE)) %>%
    ggplot(aes(x = reorder(attack_type, success_rate), y = success_rate)) +
    geom_col(fill = "darkblue", alpha = 0.7) +
    coord_flip() +
    theme_minimal() +
    labs(title = "Taux de Succès par Type d'Attaque",
         x = "Type d'attaque",
         y = "Taux de succès")
  
  # Victimes moyennes par type d'attaque
  p2 <- data %>%
    group_by(attack_type) %>%
    summarise(avg_killed = mean(killed, na.rm = TRUE)) %>%
    ggplot(aes(x = reorder(attack_type, avg_killed), y = avg_killed)) +
    geom_col(fill = "darkred", alpha = 0.7) +
    coord_flip() +
    theme_minimal() +
    labs(title = "Nombre Moyen de Victimes par Type d'Attaque",
         x = "Type d'attaque",
         y = "Nombre moyen de victimes")
  
  print(p1)
  print(p2)
}

# -----------------------------------------------------------------------------
#                    7. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
  # Chargement des données
  data <- read_csv("data/processed/gtd_cleaned.csv")
  
  # Création des visualisations
  message("1. Création des graphiques de distribution...")
  plot_attack_distributions(data)
  
  message("2. Création des graphiques géographiques...")
  plot_geographical_analysis(data)
  
  message("3. Création des graphiques de victimes...")
  plot_casualty_analysis(data)
  
  message("4. Création des graphiques de corrélation...")
  plot_correlation_analysis(data)
  
  message("5. Création des graphiques temporels...")
  plot_temporal_analysis(data)
  
  message("6. Création des graphiques par type d'attaque...")
  plot_attack_type_analysis(data)
  
  message("\nToutes les visualisations ont été générées!")
}

# Exécution si le script est lancé directement
if (!interactive()) {
  main()
}


```


```{r setup, include=FALSE}
# ==============================================================================
#                    CARTES INTERACTIVES RÉGIONALES GTD
# ==============================================================================

library(tidyverse)
library(leaflet)
library(RColorBrewer)
library(scales)
library(sf)
library(viridis)
library(htmlwidgets)

# -----------------------------------------------------------------------------
#                    1. CONFIGURATION INITIALE
# -----------------------------------------------------------------------------

# Configuration des régions
REGIONS_CONFIG <- list(
    south_america = list(
        name = "South America",
        color = "#2ecc71",
        bounds = c(-100, -60, -20, 25)
    ),
    north_america = list(
        name = "North America",
        color = "#3498db",
        bounds = c(-170, 0, -55, 75)
    ),
    mena = list(
        name = "Middle East & North Africa",
        color = "#e74c3c",
        bounds = c(-35, 0, 65, 60)
    ),
    subsaharan = list(
        name = "Sub-Saharan Africa",
        color = "#f1c40f",
        bounds = c(-35, -45, 65, 60)
    ),
    europe = list(
        name = c("Eastern Europe", "Western Europe"),
        color = "#9b59b6",
        bounds = c(-15, 10, 70, 75)
    ),
    asia = list(
        name = c("South Asia", "Southeast Asia", "Central Asia", "East Asia"),
        color = "#1abc9c",
        bounds = c(30, -15, 165, 70)
    )
)

# Palettes de couleurs améliorées
COLORS <- list(
    attack = colorRampPalette(c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c"))(5),
    region = viridis(8, alpha = 0.8),
    severity = c(
        Faible = "#2ecc71",
        Moyen = "#f1c40f",
        Élevé = "#e74c3c"
    )
)

# -----------------------------------------------------------------------------
#                    2. FONCTIONS DE PRÉPARATION DES DONNÉES
# -----------------------------------------------------------------------------

prepare_data <- function(data, region_name) {
    data %>%
        filter(region_txt %in% region_name,
               !is.na(longitude),
               !is.na(latitude)) %>%
        mutate(
            killed_cat = cut(nkill,
                           breaks = c(-Inf, 0, 5, 10, 25, Inf),
                           labels = c("0", "1-5", "6-10", "11-25", ">25")),
            year = iyear,
            popup_text = sprintf(
                "<div class='popup-content'>
                    <h3>Détails de l'incident</h3>
                    <p><b>Année:</b> %d</p>
                    <p><b>Pays:</b> %s</p>
                    <p><b>Ville:</b> %s</p>
                    <p><b>Morts:</b> %d</p>
                    <p><b>Blessés:</b> %d</p>
                    <p><b>Type d'attaque:</b> %s</p>
                </div>",
                iyear, country_txt, city, nkill, nwound, attacktype1_txt
            )
        )
}

# -----------------------------------------------------------------------------
#                    3. FONCTION DE CRÉATION DE CARTE RÉGIONALE
# -----------------------------------------------------------------------------

create_region_map <- function(data, region_config) {
    region_data <- prepare_data(data, region_config$name)
    
    leaflet(region_data) %>%
        # Fond de carte
        addProviderTiles(
            providers$CartoDB.Positron,
            options = providerTileOptions(minZoom = 2)
        ) %>%
        # Ajustement des limites
        fitBounds(
            region_config$bounds[1],
            region_config$bounds[2],
            region_config$bounds[3],
            region_config$bounds[4]
        ) %>%
        # Marqueurs des incidents
        addCircleMarkers(
            lng = ~longitude,
            lat = ~latitude,
            radius = ~sqrt(nkill + 1) * 3,
            color = region_config$color,
            fillOpacity = 0.7,
            stroke = FALSE,
            popup = ~popup_text,
            clusterOptions = markerClusterOptions(
                iconCreateFunction = JS("
                    function(cluster) {
                        return L.divIcon({
                            html: '<div style=\"
                                background-color: rgba(70, 130, 180, 0.8);
                                width: 40px;
                                height: 40px;
                                border-radius: 20px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                color: white;
                                font-weight: bold;
                            \">' + cluster.getChildCount() + '</div>',
                            className: 'marker-cluster',
                            iconSize: L.point(40, 40)
                        });
                    }
                ")
            )
        ) %>%
        # Légende
        addLegend(
            position = "bottomright",
            title = "Nombre de victimes",
            colors = COLORS$attack,
            labels = c("0", "1-5", "6-10", "11-25", ">25"),
            opacity = 0.7
        )
}

# -----------------------------------------------------------------------------
#                    4. FONCTION DE CARTE MONDIALE
# -----------------------------------------------------------------------------

create_global_severity_map <- function(data) {
    prepared_data <- data %>%
        filter(!is.na(longitude), !is.na(latitude)) %>%
        mutate(
            severity = case_when(
                nkill <= 5 ~ "Faible",
                nkill <= 10 ~ "Moyen",
                TRUE ~ "Élevé"
            ),
            severity_color = COLORS$severity[severity],
            popup_text = sprintf(
                "<div class='popup-content'>
                    <h3>Détails de l'incident</h3>
                    <p><b>Année:</b> %d</p>
                    <p><b>Pays:</b> %s</p>
                    <p><b>Gravité:</b> %s</p>
                    <p><b>Morts:</b> %d</p>
                    <p><b>Blessés:</b> %d</p>
                    <p><b>Type d'attaque:</b> %s</p>
                </div>",
                iyear, country_txt, severity, nkill, nwound, attacktype1_txt
            )
        )
    
    leaflet(prepared_data) %>%
        addProviderTiles(
            providers$CartoDB.Positron,
            options = providerTileOptions(minZoom = 2)
        ) %>%
        addCircleMarkers(
            lng = ~longitude,
            lat = ~latitude,
            radius = ~sqrt(nkill + 1) * 2,
            color = ~severity_color,
            fillOpacity = 0.7,
            stroke = FALSE,
            popup = ~popup_text,
            clusterOptions = markerClusterOptions()
        ) %>%
        addLegend(
            position = "bottomright",
            colors = unname(COLORS$severity),
            labels = names(COLORS$severity),
            title = "Gravité des attaques",
            opacity = 0.7
        )
}

# -----------------------------------------------------------------------------
#                    5. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
    # Création du dossier pour les cartes
    dir.create("visualizations/maps", recursive = TRUE, showWarnings = FALSE)
    
    # Chargement des données
    message("Chargement des données...")
    data <- read_csv("data/processed/gtd_cleaned.csv")
    
    # Création des cartes régionales
    message("Création des cartes régionales...")
    maps <- list()
    
    for(region_name in names(REGIONS_CONFIG)) {
        message(sprintf("Création de la carte pour %s...", region_name))
        maps[[region_name]] <- create_region_map(data, REGIONS_CONFIG[[region_name]])
        saveWidget(maps[[region_name]], 
                  sprintf("visualizations/maps/%s_map.html", region_name))
    }
    
    # Création de la carte mondiale
    message("Création de la carte mondiale...")
    global_map <- create_global_severity_map(data)
    saveWidget(global_map, "visualizations/maps/global_map.html")
    
    message("Toutes les cartes ont été générées avec succès!")
    return(maps)
}

# Exécution si le script est lancé directement
if (!interactive()) {
    main()
}
```


```{r setup, include=FALSE}
# ==============================================================================
#                    MODÉLISATION PRÉDICTIVE DES ATTAQUES TERRORISTES
# ==============================================================================

library(tidyverse)
library(caret)
library(randomForest)
library(xgboost)
library(ROCR)
library(e1071)
library(nnet)
library(plotly)
library(viridis)

# -----------------------------------------------------------------------------
#                    1. PRÉPARATION DES DONNÉES
# -----------------------------------------------------------------------------

prepare_data_for_modeling <- function(data) {
  message("Préparation des données pour la modélisation...")
  
  # Sélection et préparation des variables
  model_data <- data %>%
    mutate(
      # Variable cible : succès de l'attaque (binaire)
      success = as.factor(success),
      # Variables temporelles
      month = as.factor(month),
      weekday = as.factor(weekday),
      # Variables catégorielles
      region = as.factor(region),
      country = as.factor(country),
      attack_type = as.factor(attack_type),
      target_type = as.factor(target_type),
      weapon_type = as.factor(weapon_type)
    ) %>%
    # Sélection des variables pour le modèle
    select(success, year, month, weekday, region, country, 
           attack_type, target_type, weapon_type, 
           latitude, longitude, killed, wounded)
  
  # Gestion des valeurs manquantes
  model_data <- model_data %>%
    mutate_if(is.numeric, ~replace_na(., median(., na.rm = TRUE))) %>%
    mutate_if(is.factor, ~replace_na(., "Unknown"))
  
  return(model_data)
}

# -----------------------------------------------------------------------------
#                    2. DIVISION DES DONNÉES
# -----------------------------------------------------------------------------

split_data <- function(data, train_ratio = 0.8) {
  message("Division des données en ensembles d'entraînement et de test...")
  
  # Création de l'index pour la division
  set.seed(42)
  train_index <- createDataPartition(data$success, p = train_ratio, list = FALSE)
  
  # Division des données
  train_data <- data[train_index, ]
  test_data <- data[-train_index, ]
  
  return(list(train = train_data, test = test_data))
}

# -----------------------------------------------------------------------------
#                    3. ENTRAÎNEMENT DES MODÈLES
# -----------------------------------------------------------------------------

train_models <- function(train_data, test_data) {
  message("Entraînement des modèles...")
  
  # Configuration du contrôle d'entraînement
  ctrl <- trainControl(
    method = "cv",
    number = 5,
    classProbs = TRUE,
    summaryFunction = twoClassSummary
  )
  
  # 1. Régression Logistique
  message("Entraînement du modèle de régression logistique...")
  logistic_model <- train(
    success ~ .,
    data = train_data,
    method = "glm",
    family = "binomial",
    trControl = ctrl,
    metric = "ROC"
  )
  
  # 2. Random Forest
  message("Entraînement du modèle Random Forest...")
  rf_model <- train(
    success ~ .,
    data = train_data,
    method = "rf",
    trControl = ctrl,
    metric = "ROC",
    ntree = 100
  )
  
  # 3. XGBoost
  message("Entraînement du modèle XGBoost...")
  xgb_model <- train(
    success ~ .,
    data = train_data,
    method = "xgbTree",
    trControl = ctrl,
    metric = "ROC"
  )
  
  # 4. Neural Network
  message("Entraînement du réseau de neurones...")
  nnet_model <- train(
    success ~ .,
    data = train_data,
    method = "nnet",
    trControl = ctrl,
    metric = "ROC",
    trace = FALSE
  )
  
  return(list(
    logistic = logistic_model,
    random_forest = rf_model,
    xgboost = xgb_model,
    neural_net = nnet_model
  ))
}

# -----------------------------------------------------------------------------
#                    4. ÉVALUATION DES MODÈLES
# -----------------------------------------------------------------------------

evaluate_models <- function(models, test_data) {
  message("Évaluation des modèles...")
  
  # Fonction pour calculer les métriques
  calculate_metrics <- function(model, name) {
    # Prédictions
    pred <- predict(model, test_data)
    prob <- predict(model, test_data, type = "prob")
    
    # Matrice de confusion
    conf_matrix <- confusionMatrix(pred, test_data$success)
    
    # Courbe ROC
    pred_obj <- prediction(prob[,2], test_data$success)
    perf_obj <- performance(pred_obj, "tpr", "fpr")
    auc <- performance(pred_obj, "auc")@y.values[[1]]
    
    # Métriques
    metrics <- data.frame(
      Model = name,
      Accuracy = conf_matrix$overall["Accuracy"],
      Precision = conf_matrix$byClass["Precision"],
      Recall = conf_matrix$byClass["Recall"],
      F1_Score = conf_matrix$byClass["F1"],
      AUC = auc
    )
    
    return(list(
      metrics = metrics,
      roc_curve = list(
        fpr = perf_obj@x.values[[1]],
        tpr = perf_obj@y.values[[1]]
      )
    ))
  }
  
  # Calcul des métriques pour chaque modèle
  evaluations <- list(
    logistic = calculate_metrics(models$logistic, "Régression Logistique"),
    random_forest = calculate_metrics(models$random_forest, "Random Forest"),
    xgboost = calculate_metrics(models$xgboost, "XGBoost"),
    neural_net = calculate_metrics(models$neural_net, "Réseau de Neurones")
  )
  
  return(evaluations)
}

# -----------------------------------------------------------------------------
#                    5. VISUALISATION DES RÉSULTATS
# -----------------------------------------------------------------------------

visualize_results <- function(evaluations) {
  message("Création des visualisations des résultats...")
  
  # Compilation des métriques
  all_metrics <- bind_rows(
    evaluations$logistic$metrics,
    evaluations$random_forest$metrics,
    evaluations$xgboost$metrics,
    evaluations$neural_net$metrics
  )
  
  # Graphique des métriques
  metrics_plot <- all_metrics %>%
    gather(key = "Metric", value = "Value", -Model) %>%
    ggplot(aes(x = Model, y = Value, fill = Metric)) +
    geom_bar(stat = "identity", position = "dodge") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_viridis_d() +
    labs(title = "Comparaison des Performances des Modèles",
         y = "Valeur",
         x = "Modèle")
  
  # Courbes ROC
  roc_data <- data.frame()
  for(model_name in names(evaluations)) {
    roc_data <- bind_rows(
      roc_data,
      data.frame(
        Model = model_name,
        FPR = evaluations[[model_name]]$roc_curve$fpr,
        TPR = evaluations[[model_name]]$
          TPR
      )
    )
  }
  
  roc_plot <- ggplot(roc_data, aes(x = FPR, y = TPR, color = Model)) +
    geom_line(size = 1) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
    theme_minimal() +
    scale_color_viridis_d() +
    labs(title = "Courbes ROC des Modèles",
         x = "Taux de Faux Positifs (FPR)",
         y = "Taux de Vrais Positifs (TPR)",
         color = "Modèle")
  
  return(list(metrics_plot = metrics_plot, roc_plot = roc_plot))
}

# -----------------------------------------------------------------------------
#                    6. IMPORTANCE DES VARIABLES
# -----------------------------------------------------------------------------

analyze_feature_importance <- function(models) {
  message("Analyse de l'importance des variables...")
  
  # Importance des variables pour Random Forest
  rf_importance <- varImp(models$random_forest, scale = TRUE)$importance
  rf_importance$Variable <- rownames(rf_importance)
  
  # Visualisation
  importance_plot <- rf_importance %>%
    arrange(desc(Overall)) %>%
    mutate(Variable = factor(Variable, levels = Variable)) %>%
    ggplot(aes(x = Variable, y = Overall)) +
    geom_bar(stat = "identity", fill = "darkblue", alpha = 0.8) +
    coord_flip() +
    theme_minimal() +
    labs(title = "Importance des Variables - Random Forest",
         x = "Variables",
         y = "Score d'Importance")
  
  return(importance_plot)
}

# -----------------------------------------------------------------------------
#                    7. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
  # Création du dossier pour les résultats
  dir.create("results/models", recursive = TRUE, showWarnings = FALSE)
  
  # Chargement des données
  message("Chargement des données...")
  data <- read_csv("data/processed/gtd_cleaned.csv")
  
  # Préparation des données
  model_data <- prepare_data_for_modeling(data)
  
  # Division des données
  data_split <- split_data(model_data)
  
  # Entraînement des modèles
  models <- train_models(data_split$train, data_split$test)
  
  # Évaluation des modèles
  evaluations <- evaluate_models(models, data_split$test)
  
  # Visualisation des résultats
  plots <- visualize_results(evaluations)
  importance_plot <- analyze_feature_importance(models)
  
  # Sauvegarde des résultats
  message("\nSauvegarde des résultats et des graphiques...")
  saveRDS(models, "results/models/trained_models.rds")
  ggsave("results/models/metrics_comparison.png", plots$metrics_plot, width = 12, height = 8)
  ggsave("results/models/roc_curves.png", plots$roc_plot, width = 10, height = 8)
  ggsave("results/models/feature_importance.png", importance_plot, width = 10, height = 8)
  
  message("Analyse prédictive et sauvegarde terminées avec succès!")
}

# Exécution si le script est lancé directement
if (!interactive()) {
  main()
}

          
```


```{r setup, include=FALSE}
# ==============================================================================
#                    PRÉDICTION DES FUTURES ATTAQUES TERRORISTES
# ==============================================================================

library(tidyverse)
library(forecast)
library(tsibble)
library(prophet)
library(zoo)
library(plotly)
library(viridis)
library(lubridate)

# -----------------------------------------------------------------------------
#                    1. PRÉPARATION DES DONNÉES
# -----------------------------------------------------------------------------

prepare_time_series_data <- function(data) {
    message("Préparation des données temporelles...")
    
    # Agrégation mensuelle
    monthly_data <- data %>%
        mutate(date = make_date(year, month, 1)) %>%
        group_by(date) %>%
        summarise(
            attacks = n(),
            casualties = sum(killed, na.rm = TRUE),
            .groups = "drop"
        )
    
    # Agrégation par région
    regional_data <- data %>%
        mutate(date = make_date(year, month, 1)) %>%
        group_by(date, region) %>%
        summarise(
            attacks = n(),
            casualties = sum(killed, na.rm = TRUE),
            .groups = "drop"
        )
    
    list(
        monthly = monthly_data,
        regional = regional_data
    )
}

# -----------------------------------------------------------------------------
#                    2. MODÈLES DE PRÉDICTION
# -----------------------------------------------------------------------------

# Modèle ARIMA
train_arima_model <- function(data, horizon = 12) {
    message("Entraînement du modèle ARIMA...")
    
    # Création de la série temporelle
    ts_data <- ts(data$attacks, 
                  frequency = 12,
                  start = c(year(min(data$date)), month(min(data$date))))
    
    # Ajustement automatique du modèle ARIMA
    model <- auto.arima(ts_data, seasonal = TRUE)
    
    # Prédictions
    predictions <- forecast(model, h = horizon)
    
    return(list(
        model = model,
        predictions = predictions
    ))
}

# Modèle Prophet
train_prophet_model <- function(data, horizon = 12) {
    message("Entraînement du modèle Prophet...")
    
    # Préparation des données pour Prophet
    prophet_data <- data %>%
        rename(ds = date, y = attacks)
    
    # Entraînement du modèle
    model <- prophet(prophet_data, yearly.seasonality = TRUE, 
                    weekly.seasonality = FALSE, daily.seasonality = FALSE)
    
    # Création du dataframe futur
    future <- make_future_dataframe(model, periods = horizon, freq = "month")
    
    # Prédictions
    predictions <- predict(model, future)
    
    return(list(
        model = model,
        predictions = predictions
    ))
}

# Modèle par région
train_regional_models <- function(data, horizon = 12) {
    message("Entraînement des modèles régionaux...")
    
    # Création d'un modèle Prophet pour chaque région
    regional_models <- data %>%
        split(.$region) %>%
        map(function(region_data) {
            prophet_data <- region_data %>%
                rename(ds = date, y = attacks)
            
            model <- prophet(prophet_data, yearly.seasonality = TRUE,
                           weekly.seasonality = FALSE, daily.seasonality = FALSE)
            
            future <- make_future_dataframe(model, periods = horizon, freq = "month")
            predictions <- predict(model, future)
            
            list(
                model = model,
                predictions = predictions
            )
        })
    
    return(regional_models)
}

# -----------------------------------------------------------------------------
#                    3. VISUALISATION DES PRÉDICTIONS
# -----------------------------------------------------------------------------

plot_predictions <- function(data, arima_pred, prophet_pred) {
    message("Création des visualisations des prédictions...")
    
    # Préparation des données de prédiction ARIMA
    arima_df <- data.frame(
        date = seq.Date(from = max(data$date) + months(1),
                       by = "month", length.out = length(arima_pred$mean)),
        prediction = as.numeric(arima_pred$mean),
        lower = as.numeric(arima_pred$lower[,"95%"]),
        upper = as.numeric(arima_pred$upper[,"95%"]),
        model = "ARIMA"
    )
    
    # Préparation des données de prédiction Prophet
    prophet_df <- data.frame(
        date = prophet_pred$ds,
        prediction = prophet_pred$yhat,
        lower = prophet_pred$yhat_lower,
        upper = prophet_pred$yhat_upper,
        model = "Prophet"
    ) %>%
        filter(date > max(data$date))
    
    # Création du graphique
    p <- plot_ly() %>%
        # Données historiques
        add_lines(data = data,
                 x = ~date, y = ~attacks,
                 name = "Historique",
                 line = list(color = "black")) %>%
        # Prédictions ARIMA
        add_lines(data = arima_df,
                 x = ~date, y = ~prediction,
                 name = "ARIMA",
                 line = list(color = "blue", dash = "dash")) %>%
        add_ribbons(data = arima_df,
                   x = ~date, ymin = ~lower, ymax = ~upper,
                   name = "IC ARIMA",
                   fillcolor = "rgba(0,0,255,0.2)",
                   line = list(color = "transparent")) %>%
        # Prédictions Prophet
        add_lines(data = prophet_df,
                 x = ~date, y = ~prediction,
                 name = "Prophet",
                 line = list(color = "red", dash = "dash")) %>%
        add_ribbons(data = prophet_df,
                   x = ~date, ymin = ~lower, ymax = ~upper,
                   name = "IC Prophet",
                   fillcolor = "rgba(255,0,0,0.2)",
                   line = list(color = "transparent")) %>%
        layout(title = "Prédiction des Attaques Terroristes",
               xaxis = list(title = "Date"),
               yaxis = list(title = "Nombre d'attaques"))
    
    return(p)
}

plot_regional_predictions <- function(data, regional_models) {
    message("Création des visualisations des prédictions régionales...")
    
    # Création d'un graphique pour chaque région
    plots <- imap(regional_models, function(model, region) {
        region_data <- data %>%
            filter(region == !!region)
        
        pred_df <- model$predictions %>%
            filter(ds > max(region_data$date))
        
        plot_ly() %>%
            add_lines(data = region_data,
                     x = ~date, y = ~attacks,
                     name = "Historique",
                     line = list(color = "black")) %>%
            add_lines(data = pred_df,
                     x = ~ds, y = ~yhat,
                     name = "Prédiction",
                     line = list(color = "red", dash = "dash")) %>%
            add_ribbons(data = pred_df,
                       x = ~ds, ymin = ~yhat_lower, ymax = ~yhat_upper,
                       name = "Intervalle de confiance",
                       fillcolor = "rgba(255,0,0,0.2)",
                       line = list(color = "transparent")) %>%
            layout(title = paste("Prédictions pour", region),
                   xaxis = list(title = "Date"),
                   yaxis = list(title = "Nombre d'attaques"))
    })
    
    return(plots)
}

# -----------------------------------------------------------------------------
#                    4. ÉVALUATION DES MODÈLES
# -----------------------------------------------------------------------------

evaluate_predictions <- function(data, arima_model, prophet_model) {
    message("Évaluation des modèles de prédiction...")
    
    # Division des données pour validation
    train_size <- floor(0.8 * nrow(data))
    train_data <- data[1:train_size, ]
    test_data <- data[(train_size+1):nrow(data), ]
    
    # Entraînement et prédiction sur les données de test
    arima_test <- train_arima_model(train_data, horizon = nrow(test_data))
    prophet_test <- train_prophet_model(train_data, horizon = nrow(test_data))
    
    # Calcul des métriques
    metrics <- data.frame(
        Model = c("ARIMA", "Prophet"),
        RMSE = c(
            sqrt(mean((test_data$attacks - as.numeric(arima_test$predictions$mean))^2)),
            sqrt(mean((test_data$attacks - prophet_test$predictions$yhat[(train_size+1):nrow(data)])^2))
        ),
        MAE = c(
            mean(abs(test_data$attacks - as.numeric(arima_test$predictions$mean))),
            mean(abs(test_data$attacks - prophet_test$predictions$yhat[(train_size+1):nrow(data)]))
        )
    )
    
    return(metrics)
}

# -----------------------------------------------------------------------------
#                    5. FONCTION PRINCIPALE
# -----------------------------------------------------------------------------

main <- function() {
    # Création du dossier pour les résultats
    dir.create("results/predictions", recursive = TRUE, showWarnings = FALSE)
    
    # Chargement des données
    message("Chargement des données...")
    data <- read_csv("data/processed/gtd_cleaned.csv")
    
    # Préparation des données
    ts_data <- prepare_time_series_data(data)
    
    # Entraînement des modèles
    arima_results <- train_arima_model(ts_data$monthly)
    prophet_results <- train_prophet_model(ts_data$monthly)
    regional_models <- train_regional_models(ts_data$regional)
    
    # Création des visualisations
    global_pred_plot <- plot_predictions(
        ts_data$monthly,
        arima_results$predictions,
        prophet_results$predictions
    )
    
    regional_plots <- plot_regional_predictions(
        ts_data$regional,
        regional_models
    )
    
    # Évaluation des modèles
    metrics <- evaluate_predictions(
        ts_data$monthly,
        arima_results$model,
        prophet_results$model
    )
    
    # Sauvegarde des résultats
    message("\nSauvegarde des résultats...")
    saveRDS(list(
        arima = arima_results,
        prophet = prophet_results,
        regional = regional_models
    ), "results/predictions/time_series_models.rds")
    
    # Sauvegarde des visualisations
    htmlwidgets::saveWidget(global_pred_plot,
                          "results/predictions/global_predictions.html")
    
    for (region in names(regional_plots)) {
        htmlwidgets::saveWidget(
            regional_plots[[region]],
            sprintf("results/predictions/%s_predictions.html",
                   make.names(region))
        )
    }
    
    # Sauvegarde des métriques
    write_csv(metrics, "results/predictions/model_metrics.csv")
    
    message("Prédictions terminées avec succès!")
    
    return(list(
        models = list(
            arima = arima_results,
            prophet = prophet_results,
            regional = regional_models
        ),
        plots = list(
            global = global_pred_plot,
            regional = regional_plots
        ),
        metrics = metrics
    ))
}

# Exécution si le script est lancé directement
if (!interactive()) {
    main()
}
